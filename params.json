{"name":"CLUnit","tagline":"Common Lisp Unit Test Framework","body":"## CLUnit\r\nCLUnit is a Common Lisp unit testing framework. It is designed to be easy to use so that you can quickly start testing.\r\n\r\nCLUnit provides a rich set of features aimed at improving your unit testing experience:\r\n+ Multiple inheritance for test suites allows you to group tests into hierarchies.\r\n+ Composes the test results of each test run into a single report.\r\n+ Allows redefinition of inline functions and macros without having to redefine your tests.\r\n+ Supports composable test suite fixtures.\r\n+ Allows for an interactive testing process which gives you access to the test environment.\r\n+ Provides visual feeback of the unit test progress.\r\n+ Extensible test reporting. Builtin support for default reporting and [TAP][3] output.\r\n\r\n### Table of Contents\r\n1. Documentation\r\n2. Tutorial\r\n    1. Creating the test hierarchy\r\n    2. Defining a test\r\n    3. Running our first test\r\n    4. Changing the report format\r\n    5. Controlling diagnostic output\r\n    6. Interactive tests\r\n    7. Defining and using fixtures\r\n\r\n#### Documentation\r\nThe API documentation can be found [here][1]. If you are interested in the story behind CLUnit you can find it [here][2].\r\n\r\n\r\n#### Tutorial\r\nFor this tutorial we will write a unit test for our hypothetical number crunching library. Our unit test contains four test suites and five test cases. The image below gives a visual representation of our test hierarchy.\r\n\r\n![Test suite heirarchy](/api/images/example-test-suite.png)\r\n<br/>\r\n\r\n##### Creating the test hierarchy\r\nTo create the test suite hierarchy shown in the image we use the following code.\r\n\r\n```lisp\r\n;; Test suite for all number operation tests.\r\n(defsuite NumberSuite ())\r\n\r\n;; Test suite for floating point operations\r\n(defsuite FloatSuite (NumberSuite))\r\n\r\n;; Test suite for integer operations.\r\n(defsuite IntegerSuite (NumberSuite))\r\n\r\n; Test suite for boolean operations on numbers.\r\n(defsuite BooleanSuite (FloatSuite IntegerSuite))\r\n```\r\n<br/>\r\n\r\n##### Defining a test\r\nNext we define two test cases for our ```FloatSuite ``` and ```IntegerSuite ``` test suites. Each test contains two assertion forms.\r\n\r\n```ASSERT-TRUE``` considers the assertion a pass if the expression supplied to it returns true and ```(ASSERT-EQUAL value expression)``` considers the assertion to have passed if ```(EQUAL value expression)``` returns true.\r\n\r\n```lisp\r\n;; Define a test called TEST-INT1\r\n(deftest test-int1 (IntegerSuite)\r\n\t(assert-true  (= 1 -1))\r\n\t(assert-equal 4 (+ 2 2)))\r\n\r\n;; Define a test called TEST-FLOAT1\r\n(deftest test-float1 (FloatSuite)\r\n\t(assert-true (= 1.0 -1.0))\r\n\t(assert-equal 4.0 (+ 2.0 2.0)))\r\n```\r\n<br/>\r\n\r\n##### Running our first test\r\nTo run an individual test you use the form ```(RUN-TEST 'test-name)```, however we are interested in running the entire test suite so we shall use the form  ```(RUN-SUITE 'test-name)```.\r\n\r\n```lisp\r\n(run-suite 'NumberSuite)\r\n\r\nPROGRESS:\r\n=========\r\n\r\n    NUMBERSUITE: (Test Suite)\r\n\r\n        INTEGERSUITE: (Test Suite)\r\n            TEST-INT1: F.\r\n\r\n            BOOLEANSUITE: (Test Suite)\r\n\r\n        FLOATSUITE: (Test Suite)\r\n            TEST-FLOAT1: F.\r\n\r\n            BOOLEANSUITE: (Test Suite)\r\nDETAILS:\r\n=========\r\n\r\n    NUMBERSUITE -> INTEGERSUITE: (Test Suite)\r\n        TEST-INT1: Expression: (= 1 -1)\r\n                   Expected: T\r\n                   Returned: NIL\r\n\r\n    NUMBERSUITE -> FLOATSUITE: (Test Suite)\r\n        TEST-FLOAT1: Expression: (= 1.0 -1.0)\r\n                     Expected: T\r\n                     Returned: NIL\r\nSUMMARY:\r\n========\r\n    Tested 4 assertions.\r\n        Passed: 2/4 ( 50.0%)\r\n        Failed: 2/4 ( 50.0%)\r\n        Errors: 0/4 (  0.0%)\r\n```\r\n\r\nThe functions ```RUN-SUITE``` and ```RUN-TEST``` by default print out the test progress as they execute. The function ```RUN-SUITE``` first executes the tests referred to by the test suite argument. After executing the test cases, it then executes the child test suites. This process is repeated recursively until all the test cases and test suites in the hierarchy have been executed.\r\n\r\nDuring the test progress, the names of test suites and test cases are printed using a visual format that shows how the hierarchy is nested. Each assertion in a test case prints either ```.``` for a pass or ```F``` for a failure. An ```E``` is printed when an error occurs in the test, when an ```E``` is seen it means there is a serious problem in your code and the rest of the test case is skipped.\r\n\r\nThe progress report can be switched off by setting the ```:report-progress``` keyword argument to ```NIL``` for example:\r\n\r\n```lisp\r\n(run-suite 'NumberSuite :report-progress nil)\r\nDETAILS:\r\n=========\r\n\r\n    NUMBERSUITE -> INTEGERSUITE: (Test Suite)\r\n        TEST-INT1: Expression: (= 1 -1)\r\n                   Expected: T\r\n                   Returned: NIL\r\n\r\n    NUMBERSUITE -> FLOATSUITE: (Test Suite)\r\n        TEST-FLOAT1: Expression: (= 1.0 -1.0)\r\n                     Expected: T\r\n                     Returned: NIL\r\nSUMMARY:\r\n========\r\n    Tested 4 assertions.\r\n        Passed: 2/4 ( 50.0%)\r\n        Failed: 2/4 ( 50.0%)\r\n        Errors: 0/4 (  0.0%)\r\n```\r\n<br/>\r\n\r\n##### Changing the report format\r\nThe functions ```RUN-SUITE``` and ```RUN-TEST``` return a ```CLUNIT-REPORT``` object, the default ```PRINT-OBJECT``` method prints the aggregated details of the unit test failures and a test summary. \r\n\r\nThe variable ```clunit:*clunit-report-format*``` controls the output format of the unit test results. Possible values are ```:default```, ```:tap``` or ```NIL```. The value ```:tap``` sets the reporting to [TAP][3] output.\r\n\r\n```lisp\r\n(setf clunit:*clunit-report-format* :tap)\r\n(run-suite 'NumberSuite :report-progress nil)\r\nTAP version 13\r\n1..4\r\nnot ok 1\r\n    #  Suite: NUMBERSUITE -> INTEGERSUITE\r\n    #  Test: TEST-INT1\r\n    #  Expression: (= 1 -1)\r\n    #  Expected: T\r\n    #  Returned: NIL\r\nok 2\r\nnot ok 3\r\n    #  Suite: NUMBERSUITE -> FLOATSUITE\r\n    #  Test: TEST-FLOAT1\r\n    #  Expression: (= 1.0 -1.0)\r\n    #  Expected: T\r\n    #  Returned: NIL\r\nok 4\r\n```\r\n<br/>\r\n\r\n##### Controlling diagnostic output\r\nApart from the mandatory arguments, the assertion forms accept additional arguments that will be printed if an error occurs. An assertion macro call then takes the the following form:\r\n```lisp\r\n(ASSERT-TRUE expression [form1] [form2] ... [formN])\r\n```\r\nIf the assertion fails the form and its value is printed. However, if the form is a string only the value is printed so this can be used to insert comments into the diagnostic output.\r\n```lisp\r\n(deftest test-suiteless ()\r\n\t(let ((a 1) (b 2) (c 3))\r\n\t\t(assert-true (= a b c) \"This assertion is meant to fail.\" a b c )))\r\n\r\n(run-test 'test-suiteless :report-progress nil)\r\n\r\nDETAILS:\r\n=========\r\n    TEST-SUITELESS: Expression: (= A B C)\r\n                    Expected: T\r\n                    Returned: NIL\r\n                    This assertion is meant to fail.\r\n                    A => 1\r\n                    B => 2\r\n                    C => 3\r\nSUMMARY:\r\n========\r\n    Tested 1 assertion.\r\n        Passed: 0/1 (  0.0%)\r\n        Failed: 1/1 (100.0%)\r\n        Errors: 0/1 (  0.0%)\r\n```\r\n<br/>\r\n\r\n##### Interactive tests\r\nThe functions ```RUN-SUITE``` and ```RUN-TEST``` accept another keyword argument called ```:use-debugger```. If this argument is set to true, the unit test will fall into the debugger if an assesrtion fails.\r\n```lisp\r\n(run-suite 'NumberSuite :report-progress nil :use-debugger t)\r\n\r\nDebugger invoked on a CLUNIT::ASSERTION-CONDITION:\r\n  TEST-INT1: Expression: (= 1 -1)\r\n             Expected: T\r\n             Returned: NIL\r\n\r\nType HELP for debugger help, or (SB-EXT:QUIT) to exit from SBCL.\r\n\r\nrestarts (invokable by number or by possibly-abbreviated name):\r\n  0: [CONTINUE                  ] Continue with TEST-INT1 test.\r\n  1: [CONTINUE-WITHOUT-DEBUGGING] Continue unit test without interactive debugging.\r\n  2: [SKIP-ASSERTION            ] Skip assertion in test TEST-INT1.\r\n  3:                              Continue unit test without interactive debugging.\r\n  4: [SKIP-TEST                 ] Skip test TEST-INT1.\r\n  5: [SKIP-SUITE                ] Skip test suite INTEGERSUITE.\r\n  6:                              Skip test suite NUMBERSUITE.\r\n  7: [ABORT                     ] Exit debugger, returning to top level.\r\n```\r\n<br/>\r\n\r\n##### Defining and using fixtures\r\nFixtures are used in unit tests to setup a consistent context/enviroment in which tests can be executed so that results are reproducible. CLUnit allows you to define fixtures for each test suite.\r\n\r\nThe form ```(deffixture suite (plug) . body)``` defines a code template that is wrapped around the code of each test case and test suite that are executed by that test suite at runtime. The test case body is plugged into the template at the position identified by ```PLUG```. Fixtures are expanded at runtime, so the fixture that will wrap around a test depends on the test suite call stack. \r\n\r\n```lisp\r\n;; Fixture Definitions\r\n(deffixture IntegerSuite (@body)\r\n\t(let ((x 0) (y 1) (z 2))\r\n\t\t@body))\r\n\r\n(deffixture FloatSuite (@body)\r\n\t(let ((x 0.0) (y 1.0) (z 2.0))\r\n\t\t@body)))\r\n\r\n;; Test Case Definition\r\n(deftest test-bool1 (BooleanSuite)\r\n\t(assert-true  (< x y z))\r\n\t(assert-true  (= x y z) x y z)\r\n\t(abracadabra)\r\n\r\n(run-suite 'NumberSuite)\r\n\r\nPROGRESS:\r\n=========\r\n\r\n    NUMBERSUITE: (Test Suite)\r\n\r\n        INTEGERSUITE: (Test Suite)\r\n\r\n            BOOLEANSUITE: (Test Suite)\r\n                TEST-BOOL1: .FE\r\n\r\n        FLOATSUITE: (Test Suite)\r\n\r\n            BOOLEANSUITE: (Test Suite)\r\n                TEST-BOOL1: .FE\r\nDETAILS:\r\n=========\r\n\r\n    NUMBERSUITE -> INTEGERSUITE -> BOOLEANSUITE: (Test Suite)\r\n        TEST-BOOL1: Expression: (= X Y Z)\r\n                    Expected: T\r\n                    Returned: NIL\r\n                    X => 0\r\n                    Y => 1\r\n                    Z => 2\r\n        TEST-BOOL1: The function COMMON-LISP-USER::ABRACADABRA is undefined.\r\n\r\n    NUMBERSUITE -> FLOATSUITE -> BOOLEANSUITE: (Test Suite)\r\n        TEST-BOOL1: Expression: (= X Y Z)\r\n                    Expected: T\r\n                    Returned: NIL\r\n                    X => 0.0\r\n                    Y => 1.0\r\n                    Z => 2.0\r\n        TEST-BOOL1: The function COMMON-LISP-USER::ABRACADABRA is undefined.\r\n\r\nSUMMARY:\r\n========\r\n    Tested 6 assertions.\r\n        Passed: 2/6 ( 33.3%)\r\n        Failed: 2/6 ( 33.3%)\r\n        Errors: 2/6 ( 33.3%)\r\n```\r\n\r\n[1]: /api/clunit.xml  \"CLUnit Documentation\"\r\n[2]: http://ml.sun.ac.za/2012/11/09/developing-a-unit-test-framework-part-1/  \"Developing a unit test framework\"\r\n[3]: http://en.wikipedia.org/wiki/Test_Anything_Protocol \"Test Anything Protocol\"\r\n","google":" ","note":"Don't delete this file! It's used internally to help with page regeneration."}